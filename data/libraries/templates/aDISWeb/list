<DIV class="aDISMaske"><!-- this page shows the books, but not if they are renewable. need to click on a button for that -->
<template:meta default-text-matching="regex"/>  
 <t:switch prioritized="true">
  <FORM>
  {let $form := form(.)
   let $backButtonName := (.//input[@title = "Zurück zur vorherigen Seite"])[1]
   let $backButtonName := if ($backButtonName) then $backButtonName else (.//input[contains(@title, 'zur vorherigen Seite')])[1] (:is this line needed?:)
   let $bbn := $backButtonName/@name/string()
   return (
     if ($mode = 'lend') then (
      $extendFormPost := request-combine($form, (.//input[@type = "submit" and contains(@value, "arkierte") and contains(@value, "ngern")])[1]/{string(@name): @value}),
      $extendFormPost.post := replace($extendFormPost.post, "[a-zA-Z0-9]+=on&", "")
     ) else (
       $cancelFormPost := request-combine($form, (.//input[@type = "submit" and contains(@value, "arkierte") and contains(@value, "schen")])[1]/{string(@name): @value}),
       $cancelFormPost.post := replace($cancelFormPost.post, "[a-zA-Z0-9]+=on&", "")
     ),
     if ($bbn) then 
       $goBackPage := request-combine($form, {$bbn || ".x": "0", $bbn || ".y": "0"})
     else let $accountPage := //a[contains(., "konto")] return
       if ($accountPage) then
         $goBackPage := resolve-html($accountPage)
     else vl:raise-internal("Kein Link von der Ausleihentabelle zurück zur vorherigen Seite gefunden")
   ),
   $default-book := map:merge(({"_mode": $mode},
     switch ($mode)
       case "lend" return {"_splitIndex": $splitIndex}
       case 'ordered' case 'orderedMagazine' return {"statusId": "ordered"}
       case "provided" return {"statusId": "provided"}
       default return ()
   ))
  }

 
    <DIV class="rTable_div">
    <TABLE class="rTable_table">
    
    <thead><tr>
      <t:siblings-header>
        <th>Fällig am</th>?
        <th>Bis</th>?
        <th>Bibliothek|Ausgabeort|Zweigstelle</th>?
        <th>Titel</th>
        <th>Hinweis|Bemerkung</th>?
        <th>vorgemerkt am</th>?
        <th/>*
      </t:siblings-header>
    </tr></thead>
  
    
    <t:loop>
    <TR>
    {book := $default-book}
    <t:siblings>
    <TD>{
      if (contains(., "-")) then (book.issuedate := parse-date(substring-before(., "-"), "dd.mm.yyyy"), book.duedate := parse-date(substring-after(., "-"), "dd.mm.yyyy"))
      else book.duedate := parse-date(., "dd.mm.yyyy")
    }</TD>
    <TD>{
      if (contains(., ".")) then book.duedate := parse-date(., "dd.mm.yyyy") 
      else ()}
      <!-- vormerkungs verfall --></TD>
    <TD>{book.libraryBranch := .}</TD>
    <TD>{let
            $brs := .//br,
            $br1 := $brs[1],
            $text := if ($br1) then string-join(.//text()[. &lt;&lt; $br1]) else ., 
            $split := extract($text, "^\s*(\[([^\]]*)\])?\s*([^/]+)\s*(/\s*(.*))?", (2,3,5), "s")             
         return (
           book.category := $split[1],
           book.author := $split[3],
           book.title := $split[2],
           if ($brs) then book.id := string-join($brs/following-sibling::text(), ":")
           else ()
         )
         }
    </TD>
    <TD>{book.status := inner-text(),
         book.renewCount := extract($book.status, "([0-9]+) *Verlängerung", 1)
        }
        <t:if test="matches(., x'((nicht +verl.*ngerbar|Keine Verl.*gerung +m.*glich|Vormerkungen).*Stand +{string-join(reverse(tokenize(current-date(), '-')), '[.]')})|((Max. +)?Anzahl +der +Verl.*erreicht)','i')">
          {book.statusId := "critical"}
        </t:if>
    </TD>
    <td>
      {book.status := concat("vorgemerkt am ", inner-text()), book.statusId := "ordered"}
    </td>
    <TD>{
      if ($mode = "lend") then (.//input!(book.extendid := encode-for-uri(@name)) )
      else if ($mode = ("ordered", "requested", "provided","orderedMagazine")) then .//input!(book.cancelid := encode-for-uri(@name))
      else ()
    }</TD>
    </t:siblings>   
    </TR>
    </t:loop>
    </TABLE>

  </DIV>
 


  </form>
  
  
   
  <FORM>
    {form := .}
    
    <!--Servicebereiche-->
    <a t:condition="contains(., 'zeigen oder verlängern in:')"/>
    {let $sublinks := //a[contains(., 'zeigen oder verlängern in:')]
     return (
       nextSplitTable := ($sublinks/@href)[$splitIndex], 
       splitCount := count($sublinks)
     )
    }
  </form>
  </t:switch>
</div>